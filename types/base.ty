// Alias used by polymorphic builtins (scalar R vectors' element types)
any_scalar = int | dbl | lgl | chr | clx | raw
any_prim = p(int) | p(dbl) | p(lgl) | p(chr) | p(clx) | p(raw)
expr = {;lang|sym}
any_r_not_vec = env | null | sym | list | lang | (any -> any) | expr

error: empty -> any
fail: any -> empty

isInteger: (t(v(int)) -> c_true) & (t(~v(int)) -> c_false)
isReal: (t(v(dbl)) -> c_true) & (t(~v(dbl)) -> c_false)
IS_SCALAR: (t(v[1]('b)) -> c_true) & (t(v[int \ 1]('b)) -> c_false)

INTEGER: t(v(int)) -> *c_int
REAL: t(v(dbl)) -> *c_double

LENGTH: t(v[int('a)](any)) -> c_int('a)
XLENGTH: t(v[int('a)](any)) -> c_int('a)
Rf_envlength: t(env) -> c_int

// there is also a special case for VECSXP (list) that is coded in OCaml
allocVector: (t('a & any_prim, c_true) -> v[1]('a)) & (t('a & any_prim, (c_int \ c_true)) -> v('a)) & (t(list, 'b) -> list)

// when the names are statically known, we can return a more precise type (handled on the OCaml side)
mkNamed: (t('a & any_prim, *c_string) -> v('a)) & (t(list, *c_string) -> list)

[]<-: t(*'a, c_int, 'a) -> c_void
[]: t(*'a, c_int) -> 'a

PROTECT: t('a) -> 'a
UNPROTECT: t(c_int) -> c_void

// Arithmetic

+__2: (t(c_int, c_int) -> c_int) & (t(c_double, c_double) -> c_double) & (t(any, any) -> any) & (t(c_int_na, c_int_na) -> c_int_na) & (t(c_int_na, c_int) -> c_int_na) & (t(c_int, c_int_na) -> c_int_na)

-__2: (t(c_int, c_int) -> c_int) & (t(c_double, c_double) -> c_double) & (t(any, any) -> any) & (t(c_int_na, c_int_na) -> c_int_na) & (t(c_int_na, c_int) -> c_int_na) & (t(c_int, c_int_na) -> c_int_na)

%__2: t(c_int, c_int) -> c_int

++__1: (t(c_int) -> c_int) & (t(c_double) -> c_double) & (t(any) -> any)

*__1: t(*'a) -> 'a
&__1: t('a) -> *'a

R_INT_MIN: c_int
R_INT_MAX: c_int


Rf_envlength: t(any) -> c_int
CDR: t(any) -> any

// Boolean operators and comparisons
||__2: (t(c_true, c_true) | t(c_true, c_false) | t(c_false, c_true) -> c_true) & (t(c_false, c_false) -> c_false)
&&__2: (t(c_false, c_false) | t(c_true, c_false) | t(c_false, c_true) -> c_false) & (t(c_true, c_true) -> c_true)
==__2: t(any, any) -> c_bool
!__1: (t(c_true) -> c_false) & (t(c_false) -> c_true)
<__2: (t(c_int, c_int) -> c_bool) & (t(c_double, c_double) -> c_bool) & (t(any, any) -> c_bool)
>__2: (t(c_int, c_int) -> c_bool) & (t(c_double, c_double) -> c_bool) & (t(any, any) -> c_bool)

// TODO: add more non vector types for the 2nd overload
TYPEOF: (t(v('a)) -> 'a) & (t('b & ~vec & any_r_not_vec) -> 'b)

NA_INTEGER: c_int_na

TRUE: c_true
FALSE: c_false
R_NilValue: null

INTSXP: p(int)
REALSXP: p(dbl)
RAWSXP: p(raw)
CPLXSXP: p(clx)
STRSXP: p(chr)
LGLSXP: p(lgl)
NILSXP: null
VECSXP: list
EXPRSXP: {;lang|sym}
CLOSXP: any -> any
BUILTINSXP: any -> any
SPECIALSXP: any -> any
CHARSXP: p(chr)
SYMSXP: sym
LISTSXP: lang
LANGSXP: lang
ENVSXP: env
ANYSXP: any_r_not_vec | vec
DOTSXP: any